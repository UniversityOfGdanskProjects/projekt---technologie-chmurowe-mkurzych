\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{dsfont} 
\usepackage[polish]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[top=1in, bottom=1.5in, left=1.25in, right=1.25in]{geometry}

\usepackage{subfig}
\usepackage{multirow}
\usepackage{multicol}
\graphicspath{{Imagens/}}
\usepackage{xcolor,colortbl}
\usepackage{float}

\newcommand \comment[1]{\textbf{\textcolor{red}{#1}}}

%\usepackage{float}
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{indentfirst}
\usepackage{placeins}
\usepackage{scalefnt}
\usepackage{xcolor,listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{verbatim}
\usepackage{framed}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{HTML}{C42043}
\definecolor{backcolour}{HTML}{F2F2F2}
\definecolor{bookColor}{cmyk}{0,0,0,0.90}  
\color{bookColor}

\lstset{upquote=true}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{codepurple},
	numberstyle=\numberstyle,
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize\ttfamily,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=10pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
}
\lstset{style=mystyle}

\newcommand\numberstyle[1]{%
	\footnotesize
	\color{codegray}%
	\ttfamily
	\ifnum#1<10 0\fi#1 |%
}

\definecolor{shadecolor}{HTML}{F2F2F2}

\newenvironment{sqltable}%
{\snugshade\verbatim}%
{\endverbatim\endsnugshade}

% Margins
\addtolength{\footskip}{0cm}
\addtolength{\textwidth}{1.4cm}
\addtolength{\oddsidemargin}{-.7cm}

\addtolength{\textheight}{1.6cm}
%\addtolength{\topmargin}{-2cm}

% paragrafo
\addtolength{\parskip}{.2cm}

% Set up the header and footer
\pagestyle{fancy}
\rhead{\hmwkAuthorName} % Top left header
\lhead{\hmwkClass: \hmwkTitle} % Top center header
\rhead{\firstxmark} % Top right header
\lfoot{Marta Kurzych} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{} % Bottom right footer
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

    
\newcommand{\hmwkTitle}{AuthMaster} % Tytuł projektu
\newcommand{\hmwkDueDate}{\today} % Data 
\newcommand{\hmwkClass}{Technologie chmurowe} % Nazwa przedmiotu
\newcommand{\hmwkAuthorName}{Marta Kurzych} % Imię i nazwisko

% trabalho 
\begin{document}
% capa
\begin{titlepage}
    \vfill
	\begin{center}
	\hspace*{-1cm}
	\vspace*{0.5cm}
    \includegraphics[scale=0.55]{imagens/loga.png}\\
	\textbf{Uniwersytet Gdański \\ [0.05cm]Wydział Matematyki, Fizyki i Informatyki \\ [0.05cm] Instytut Informatyki}

	\vspace{0.6cm}
	\vspace{4cm}
	{\huge \textbf{\hmwkTitle}}\vspace{8mm}
	
	{\large \textbf{\hmwkAuthorName}}\\[3cm]
	
		\hspace{.45\textwidth} %posiciona a minipage
	   \begin{minipage}{.5\textwidth}
	   Projekt z przedmiotu technologie chmurowe na kierunku informatyka profil praktyczny na Uniwersytecie Gdańskim.\\[0.1cm]
	  \end{minipage}
	  \vfill
	%\vspace{2cm}
	
	\textbf{Gdańsk}
	
	\textbf{\hmwkDueDate}
	\end{center}
	
\end{titlepage}

\newpage
\setcounter{secnumdepth}{5}
\tableofcontents
\newpage

\section{Opis projektu}
\label{sec:Project}

Pewna firma - "Innovatech Inc." - zauważyła potrzebę kompleksowego rozwiązania do zarządzania użytkownikami i ich autoryzacją w ramach swoich aplikacji webowych. Potrzebowali bazy, która integruje nowoczesne technologie, aby zapewnić niezawodność, skalowalność i bezpieczeństwo. Tak powstał projekt "AuthMaster" - nowatorski system autoryzacji oparty na połączeniu React, Flask, MongoDB, Keycloak oraz Kubernetes. Dodatkowo, do przechowywania konfiguracji Keycloak używany jest PostgreSQL. Dzięki tej architekturze firma może sprawnie zarządzać użytkownikami, bezpiecznie przechowywać dane oraz łatwo skalować aplikację zgodnie z rosnącymi potrzebami.

\subsection{Opis architektury}
\label{sec:introduction}
Architektura aplikacji "AuthMaster" jest oparta na Kubernetes - klastrowym systemie zarządzania kontenerami, który zapewnia skalowalność i wysoką dostępność. Kluczowe komponenty to:

React stanowi interfejs użytkownika, który komunikuje się z API Flask. Flask jest serwerem backendowym obsługującym logikę aplikacji i zarządzającym sesjami użytkowników. MongoDB to baza danych NoSQL, która przechowuje informacje o użytkownikach. Keycloak działa jako serwer tożsamości, zarządzając autoryzacją i uwierzytelnianiem, a jego konfiguracja jest przechowywana w bazie danych PostgreSQL. Kubernetes jest platformą do zarządzania wdrażaniem kontenerów Docker, zapewniającą skalowanie i monitoring.

Kubernetes to open-source'owa platforma do zarządzania kontenerami, która automatyzuje wiele procesów związanych z wdrażaniem, skalowaniem i operacjami aplikacji kontenerowych. Kubernetes jest wyjątkowo elastyczny i umożliwia łatwe zarządzanie dużymi aplikacjami w różnych środowiskach.


\subsection{Opis infrastruktury}
\label{sec:Users}

Aplikacja "AuthMaster" działa w środowisku chmurowym, które zapewnia elastyczność i łatwość zarządzania zasobami. 

Kubernetes zarządza kontenerami Docker, które uruchamiają poszczególne komponenty aplikacji. Docker umożliwia tworzenie obrazów kontenerów dla React, Flask, MongoDB, Keycloak i PostgreSQL.

Kubernetes zapewnia orkiestrację kontenerów, automatyczne uruchamianie, zatrzymywanie i zarządzanie kontenerami w klastrze. System ten jest samonaprawiający, co oznacza, że automatycznie ponownie uruchamia uszkodzone kontenery, wymienia je, jeśli węzeł w klastrze zawiedzie, oraz usuwa kontenery, które nie odpowiadają na zdefiniowane testy.

\subsection{Opis komponentów aplikacji}
\label{sec:FunctionalConditions}

React tworzy dynamiczny interfejs użytkownika, który komunikuje się z API Flask poprzez zapytania HTTP. Flask obsługuje rejestrację użytkowników, logowanie, zarządzanie sesjami oraz komunikację z MongoDB i Keycloak. MongoDB przechowuje dane o użytkownikach, takie jak hasła i inne informacje profilowe. Keycloak zarządza autoryzacją i uwierzytelnianiem, zapewniając mechanizmy logowania i zarządzania sesjami, a jego konfiguracja jest przechowywana w bazie danych PostgreSQL. Kubernetes orkiestruje wdrażanie i zarządzanie kontenerami, zapewniając wysoką dostępność i skalowalność.

\subsection{Konfiguracja i zarządzanie}
\label{sec:NonFunctionalConditions}

Konfiguracja i zarządzanie aplikacją odbywa się na poziomie klastra Kubernetes. Używane są pliki YAML do definiowania podów, usług, replikasetów i deploymentów. Kluczowe elementy to ConfigMaps i Secrets, które przechowują konfiguracje i dane wrażliwe w klastrze.

ConfigMapy są używane do przechowywania zmiennych środowiskowych dla backendu. ConfigMap zawiera konfiguracje, które nie są wrażliwe i mogą być łatwo zarządzane oraz aktualizowane. 

Secrets są używane do przechowywania danych wrażliwych, takich jak hasło do bazy danych PostgresSQL. Są one zaszyfrowane w klastrze Kubernetes i dostępne tylko dla autoryzowanych podów.

\subsection{Zarządzanie błędami}
\label{sec:ERD} 

Zarządzanie błędami obejmuje kilka kluczowych aspektów, które są realizowane przy użyciu narzędzi oferowanych przez Kubernetes.

W systemie Kubernetes, zarządzanie błędami rozpoczyna się od zastosowania mechanizmów Liveness i Readiness Probes, które są wykorzystywane do monitorowania stanu aplikacji.

W przypadku Keycloak, Liveness Probe sprawdza, czy aplikacja działa prawidłowo i nie zawiesiła się.  Dzięki temu, jeśli Keycloak przestanie odpowiadać, Kubernetes automatycznie ponownie uruchomi kontener, co pomaga utrzymać aplikację w stanie operacyjnym.

Readiness Probe sprawdza, czy aplikacja jest gotowa do obsługi żądań. Jeśli aplikacja nie przejdzie tego testu, Kubernetes przestanie kierować do niej ruch. Dzięki Readiness Probe, Kubernetes może dynamicznie zarządzać ruchem do podów, zapewniając, że tylko zdrowe instancje są dostępne dla użytkowników.

W razie poważnych awarii, Kubernetes automatycznie restartuje kontenery, które przestały działać prawidłowo. Ponadto, można ustawić odpowiednie zasady retry (powtórzenia) w kodzie aplikacji oraz na poziomie warstwy sieciowej, aby zapewnić odporność na chwilowe problemy.

\subsection{Skalowalność}
\label{sec:ExamplesSection}

Skalowalność aplikacji jest zapewniona dzięki Kubernetes, który umożliwia ręczne skalowanie przez ustawienie liczby replik podów na podstawie obserwacji obciążenia. Kubernetes zapewnia elastyczność, umożliwiając dostosowywanie zasobów w zależności od potrzeb firmy. Chociaż nie jest używany w obecnej konfiguracji, Kubernetes oferuje również możliwość automatycznego skalowania liczby podów w zależności od obciążenia za pomocą Horizontal Pod Autoscaler (HPA).

\subsection{Wymagania dotyczące zasobów}
\label{sec:ExampleTables}

Każdy komponent aplikacji ma określone wymagania dotyczące zasobów. Dla React i Flask ustawiono limity zasobów na 200Mi pamięci RAM i 500m CPU. Oznacza to, że interfejs użytkownika React oraz API Flask są zoptymalizowane pod kątem niskiego zużycia zasobów, co pomaga w efektywnym zarządzaniu obciążeniem w klastrze Kubernetes.

MongoDB, jako baza danych, ma wyższe wymagania dotyczące zasobów, a dla trwałego przechowywania danych używane są Persistent Volumes (PV) o pojemności 2Gi oraz Persistent Volume Claims (PVC) o pojemności 1Gi. PostgreSQL, używany do przechowywania konfiguracji Keycloak, ma podobne wymagania dotyczące zasobów: PV o pojemności 2Gi i PVC o pojemności 1Gi. Limity zasobów dla Keycloak i PostgreSQL są ustawione odpowiednio, aby zapewnić płynne działanie systemu.


\subsection{Architektura sieciowa}
\label{sec:ExampleResults}

Architektura sieciowa aplikacji "AuthMaster" opiera się na usługach Kubernetes, które zarządzają ruchem wewnętrznym i zewnętrznym. Wszystkie pody aplikacji mają zdefiniowane serwisy (service.yml), które umożliwiają komunikację między nimi oraz z zewnętrznymi systemami. Service działa jako stabilny punkt dostępu do aplikacji działających w podach, niezależnie od tego, na którym węźle w klastrze działają te pody.

Dla komponentów takich jak Keycloak, frontend (React) i backend (Flask), dodatkowo zdefiniowane są Ingressy, które zarządzają dostępem z zewnątrz do aplikacji. Ingress Controller umożliwia zarządzanie ruchem HTTP/HTTPS, zapewniając równoważenie obciążenia oraz terminację SSL.

Ingress zapewnia, że ruch HTTP/HTTPS jest przekierowywany do odpowiednich usług w klastrze na podstawie zdefiniowanych reguł. W tym przypadku, wszystkie żądania skierowane do keycloak są przekierowywane do usługi Keycloak działającej na porcie 8080.

Taka konfiguracja umożliwia efektywne zarządzanie ruchem, zapewnia bezpieczeństwo dzięki TLS oraz ułatwia skalowanie aplikacji poprzez dodawanie kolejnych replik podów bez potrzeby zmiany konfiguracji sieciowej.

\bibliographystyle{amsplain}
\bibliography{references.bib}
\nocite{*}

\end{document}